# 递归与分治策略

## 1. 递归

> Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer. Choose which is more important in your situation! [^1] 
> 如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。

递归是指调用自己的函数，每个递归函数都有两个条件：基线条件 (Base case) 和递归条件 (recursive case) 。

- 基线条件：函数不再重复调用自身的条件，从而避免形成无限循环。 
- 递归条件：函数会重复调用自身的条件。

```python
def fact(x): # 用于计算一个数的阶乘
	if x == 1:
		return 1 # 基线条件
	else:
		return x * fact(x-1) # 递归条件
```

使用递归函数时，同样会利用栈来跟踪未完成函数的状态。当递归很深时，调用栈便会很长，因此可能占用大量的内存。如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。

-  重新编写代码，转而使用循环。
- 使用尾递归，但并非所有的语言都支持尾递归。

## 2. 分治策略

divide and conquer (D&C)

分治策略是一种解决问题的递归技巧，用于提供解决问题的思路，而非是一种解决问题的算法。
分治策略的核心是递归，可归纳为两个步骤：

- 确定基线条件，并确保该条件尽可能简单
- 确定递归条件，找出缩小问题规模的办法，并通过递归不断缩小问题的规模，直到符合基线条件为止

下面两段代码分别对列表进行循环求和与递归求和。
递归求和的方法便采用了分治策略的思想。

```python
def loop_sum(arr: list):
    # 循环求和
    total = 0
    for x in arr:
        total += x
    return total


def recursive_sum(a_list: list):
    # 递归求和
    if not a_list: # 基线条件
        return 0
    return a_list[0] + recursive_sum(a_list[1:]) # 通过递归缩小问题规模
```

Tips：编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。下面是有关列表的另外两个递归函数

```python
def recursive_count(a_list: list):
    # 递归计算列表中包含的元素
    if not a_list: # 基线条件
        return 0
    return 1 + recursive_count(a_list[1:]) # 通过递归缩小问题规模


def recursive_max(a_list: list):
    # 递归找寻列表中的最大数字
    if not a_list: # 基线条件
        return None
    elif len(a_list) == 1: # 基线条件
        return a_list[0]
    sub_max = recursive_max(a_list[1:])
    return a_list[0] if a_list[0] > sub_max else sub_max # 通过递归缩小问题规模
```

下列笔记中的递归版本均采用了分治策略的思想：

- 排序算法
- 二分查找法

[^1]: https://stackoverflow.com/questions/72209/recursion-or-iteration/72694#72694